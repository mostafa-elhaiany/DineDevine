/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
import{p as t}from"./p-1b8e1d03.js";import{MENU_BACK_BUTTON_PRIORITY as e}from"./p-185e427e.js";import{c as n}from"./p-63eb0acd.js";import{b as r}from"./p-76378400.js";import{c as s}from"./p-97c65aa5.js";const a=t=>s().duration(t?400:300),o=t=>{let e,n;const o=t.width+8,i=s(),u=s();t.isEndSide?(e=o+"px",n="0px"):(e=-o+"px",n="0px"),i.addElement(t.menuInnerEl).fromTo("transform",`translateX(${e})`,`translateX(${n})`);const c="ios"===r(t),p=c?.2:.25;return u.addElement(t.backdropEl).fromTo("opacity",.01,p),a(c).addAnimation([i,u])},i=t=>{let e,n;const o=r(t),i=t.width;t.isEndSide?(e=-i+"px",n=i+"px"):(e=i+"px",n=-i+"px");const u=s().addElement(t.menuInnerEl).fromTo("transform",`translateX(${n})`,"translateX(0px)"),c=s().addElement(t.contentEl).fromTo("transform","translateX(0px)",`translateX(${e})`),p=s().addElement(t.backdropEl).fromTo("opacity",.01,.32);return a("ios"===o).addAnimation([u,c,p])},u=t=>{const e=r(t),n=t.width*(t.isEndSide?-1:1)+"px",o=s().addElement(t.contentEl).fromTo("transform","translateX(0px)",`translateX(${n})`);return a("ios"===e).addAnimation(o)},c=(()=>{const r=new Map,s=[],a=async(e,n=!1)=>{if(await d(),"start"===e||"end"===e){const r=s.filter((t=>t.side===e&&!t.disabled));if(r.length>=1)return r.length>1&&n&&t(`menuController queried for a menu on the "${e}" side, but ${r.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,r.map((t=>t.el))),r[0].el;const a=s.filter((t=>t.side===e));if(a.length>=1)return a.length>1&&n&&t(`menuController queried for a menu on the "${e}" side, but ${a.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,a.map((t=>t.el))),a[0].el}else if(null!=e)return l((t=>t.menuId===e));return l((t=>!t.disabled))||(s.length>0?s[0].el:void 0)},c=async()=>(await d(),m()),p=(t,e)=>{r.set(t,e)},m=()=>l((t=>t._isOpen)),f=()=>s.some((t=>t.isAnimating)),l=t=>{const e=s.find(t);if(void 0!==e)return e.el},d=()=>Promise.all(Array.from(document.querySelectorAll("ion-menu")).map((t=>new Promise((e=>n(t,e))))));return p("reveal",u),p("push",i),p("overlay",o),"undefined"!=typeof document&&document.addEventListener("ionBackButton",(t=>{const n=m();n&&t.detail.register(e,(()=>n.close()))})),{registerAnimation:p,get:a,getMenus:async()=>(await d(),s.map((t=>t.el))),getOpen:c,isEnabled:async t=>{const e=await a(t);return!!e&&!e.disabled},swipeGesture:async(t,e)=>{const n=await a(e);return n&&(n.swipeGesture=t),n},isAnimating:async()=>(await d(),f()),isOpen:async t=>{if(null!=t){const e=await a(t);return void 0!==e&&e.isOpen()}return void 0!==await c()},enable:async(t,e)=>{const n=await a(e);return n&&(n.disabled=!t),n},toggle:async t=>{const e=await a(t,!0);return!!e&&e.toggle()},close:async t=>{const e=await(void 0!==t?a(t,!0):c());return void 0!==e&&e.close()},open:async t=>{const e=await a(t,!0);return!!e&&e.open()},_getOpenSync:m,_createAnimation:(t,e)=>{const n=r.get(t);if(!n)throw new Error("animation not registered");return n(e)},_register:t=>{s.indexOf(t)<0&&s.push(t)},_unregister:t=>{const e=s.indexOf(t);e>-1&&s.splice(e,1)},_setOpen:async(t,e,n)=>{if(f())return!1;if(e){const e=await c();e&&t.el!==e&&await e.setOpen(!1,!1)}return t._setOpen(e,n)}}})();export{c as m}